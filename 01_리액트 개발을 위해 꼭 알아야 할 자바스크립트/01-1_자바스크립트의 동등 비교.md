# 자바스크립트의 동등 비교

**react 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과**다.  
그리고 이 props의 동등 비교는 **객체의 얕은 비교를 기반**으로 이루어지는데, 이 얕은 비교가 리액트에서 어떻게 작동하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 크다.

아래와 같은 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

- 리액트의 가상 DOM 과 실제 DOM 의 비교
- react 컴포넌트가 렌더링할지를 판단하는 방법
- 변수나 함수의 메모이제이션

<br/>

## 자바스크립트의 데이터 타입

자바스크립트의 모든 값은 데이터 타입을 갖고 있으며, 이 데이터 타입은 크게 원시 타입과 객체 타입으로 나눌 수 있다.

- 원시 타입: boolean, null, undefined, number, string, symbol, bigint
- 객체 타입: object

### 원시 타입

원시 타입은 따로 블로그에 자세히 정리해두었다.  
[JavaScript | 원시 타입에 대한 모든 것](https://sanghee01.tistory.com/183)

### 객체 타입

원시 타입 이외의 모든 것, 즉 javascript를 이루고 있는 대부분의 타입이 객체 타입이다.  
객체 타입은 **참조를 전달**한다고 해서 참조 타입으로도 불린다.

```jsx
typeof [] === "object"; // true
typeof {} === "object"; // true

function hello() {}
typeof hello === "function"; // true

const hello1 = function () {};

const hello2 = function () {};

// 객체인 함수 내용이 같아 보여도 참조가 다르기 때문에 false를 반환한다.
hello1 === hello2; //false
```

<br/>

## 원시 타입 VS 객체 타입 - 값을 저장하는 방식의 차이

**원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식의 차이**다.  
값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만든다.

### 원시타입

```jsx
let hello = "hello world";
let hi = hello;

console.log(hello === hi); // true
```

hello의 ‘hello world’라는 값이 hi에 복사해 전달됐기 때문에 당연히 true가 나온다. 값을 비교하기 때문이다.

### 객체 타입

```jsx
var hello = {
  greet: "hello",
};

var hi = {
  greet: "hello",
};

// 객체의 내용이 완전히 동일해도 동등 비교를 할 시 false가 나온다.
console.log(hello === hi); // false

// 원시값인 내부 속성 값을 비교하면 동일하다
console.log(hello.greet === hi.greet); // true
```

반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

**객체는 값을 저장하는 게 아니라 참조를 저장하기 때문에 동등 비교시 false를 반환하게 된다.** 값은 같았을지언정 참조하는 곳이 다른 셈이다.

<br/>

## 자바스크립트의 또 다른 비교 공식, Object.is

ES6에서 추가된 비교 문법(==), 동등비교(===) 연산자의 문제점들을 해결하기 위해 만들어졌다.

두 개의 인수를 받으며 이 인수 두 개가 동일한지 확인하고 반환하는 매서드다.

1. `==` vs `Object.is`

- == 는 자동 형변환이 일어나지만 Object.is는 그렇지 않다

```jsx
5 == "5"; //true
Object.is(5, "5"); //false
```

1. `===` vs `Object.is`

- Object.is 가 좀 더 개발자가 기대하는 방식으로 동작한다.
- 객체간의 비교는 두 연산자 동일하게 참조를 기반으로 동작한다.

```jsx
-0 === +0; // false
Object.is(+0, -0); // true

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

위처럼 `==`, `===` 이 만족하지 못하는 특수한 케이스를 위해서 `Object.is`가 작동하는 것을 확인할 수 있다. 하지만 객체 간의 비교는 별 차이가 없다는 것을 참고하자.

[MDN | Object.is](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is)

<br/>

## 리액트에서의 동등 비교

**리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 Object.is이다.**

Object.is는 ES6에서 제공하는 기능이기 때문에 리액트에선 이를 구현한 폴리필(Polyfill)을 함께 사용한다.

> 💡 Polyfill이란?  
> 기본적으로 지원하지 않는 이전 브라우저에서 최신 기능을 제공하는 데 필요한 코드

리액트에서는 이를 활용해 **objectIs라는 함수를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 만들어 사용**한다. 이는 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용된다.

요약하자면, **리액트에서는 Object.is로 먼저 비교를 수행한 다음에 여기서 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한 번 더 수행**한다.

> 💡 객체 간 얕은 비교  
> 객체의 첫 번째 깊이에 존재하는 값만 비교하는 것

```jsx
// 참조가 다른 객체에 대해서 비교 불가능
Object.is({ hello: "world" }, { hello: "world" }); // false

// shallowEqual는 객체의 1 depth까지는 비교 가능
shallowEqual({ hello: "world" }, { hello: "world" }); // true

// 하지만 depth가 2이상으로 깊어지면 비교 방법이 없어 false를 리턴한다.
shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false
```

> 💡 깊이 1까지만 비교하는 이유?
>
> - 리액트에서 사용하는 JSX props는 객체이며 여기 있는 props만 일차적으로 비교하면 되기 때문이다.
> - props의 깊이가 2이상으로 깊어지게 되면 이 값들을 제대로 비교하기 위해서 재귀문이 추가되며 성능에 악영향을 끼칠 것이다. 따라서 깊이는 1로 해야 한다.
